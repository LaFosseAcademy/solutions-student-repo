# Architecture Patterns – Comparison Table

| Pattern           | MVP deadline (speed of implementation)                                             | Scaling later (ease of growth)                                                          | Team‑size suitability (4 → 8 devs)                                              | Operational complexity (ops/infra)                                                             | Future extensions (mobile, reporting, integrations)                                                                                   |
|-------------------|------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------|---------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------|
| **MVC**           | ★★★★★ – can be built in days with standard web frameworks                          | ★★☆☆☆ – scaling usually requires a major redesign                                       | ★★★☆☆ – works for a small team; larger teams hit merge‑conflict walls           | ★★☆☆☆ – single process, one container to deploy                                                | ★★☆☆☆ – adding async features or separate mobile back‑ends is cumbersome                                                              |
| **Layered**       | ★★★★☆ – extra abstraction layers add a little setup time                           | ★★☆☆☆ – still a single deployable unit, limited scaling                                 | ★★★☆☆ – clearer separation helps a growing team                                 | ★★☆☆☆ – one runtime, modest infra                                                              | ★★☆☆☆ – extensions need new layers or a full rewrite                                                                                  |
| **Monolith**      | ★★★★★ – fastest path to a working MVP (single codebase, single DB)                 | ★★☆☆☆ – horizontal scaling possible, but internal coupling makes major refactors hard   | ★★★☆☆ – easy for 4 devs; ownership blurs as the team expands                    | ★★★★★ – only one service to monitor, deploy, and back up                                       | ★★☆☆☆ – new bounded contexts (e.g., calendar sync) often force later extraction                                                       |
| **Event‑Driven**  | ★★★☆☆ – requires an internal event bus and async handlers, adding initial overhead | ★★★★★ – events decouple producers/consumers, making independent scaling straightforward | ★★★★☆ – clear producer/consumer boundaries aid parallel work for larger teams   | ★★★☆☆ – need a broker (Kafka, RabbitMQ) and queue monitoring                                   | ★★★★★ – new features can be added as listeners without touching existing code                                                         |
| **Microservices** | ★★☆☆☆ – multiple services, CI pipelines, and contracts increase upfront effort     | ★★★★★ – each service can be scaled independently, fitting the 5 k → 100 k growth path   | ★★★★★ – service ownership aligns with an 8‑person team, reduces merge conflicts | ★★☆☆☆ – many containers, service discovery, health checks, logging, and orchestration required | ★★★★★ – new capabilities (mobile API, reporting, integrations) can be introduced as separate services without impacting existing ones |
